\documentclass[draft]{article}
\usepackage{amssymb}
\usepackage{turnstile}
\usepackage{bbm}
\usepackage[greek, english]{babel}
\usepackage{MnSymbol}
\usepackage{ucs}
\usepackage{graphicx}
\usepackage{fdsymbol}

\DeclareUnicodeCharacter{9034}{\ensuremath{0}}
\DeclareUnicodeCharacter{8343}{\ensuremath{_l}}
\DeclareUnicodeCharacter{7523}{\ensuremath{_r}}
\DeclareUnicodeCharacter{9661}{\ensuremath{\mathbin{\rotatebox[origin=c]{180}{$\dotminus$}}}}
\DeclareUnicodeCharacter{9727}{\ensuremath{\mathbin{\rotatebox[origin=c]{225}{$\dotminus$}}}}
\DeclareUnicodeCharacter{9722}{\ensuremath{\mathbin{\rotatebox[origin=c]{135}{$\dotminus$}}}}
\DeclareUnicodeCharacter{9041}{\ensuremath{1}}
\DeclareUnicodeCharacter{9014}{\ensuremath{{}^{‚åà‚åâ}_{‚åä‚åã}}}
\DeclareUnicodeCharacter{737}{\ensuremath{^{l}}}
\DeclareUnicodeCharacter{691}{\ensuremath{^{r}}}
\DeclareUnicodeCharacter{8405}{\ensuremath{\minusrdots}}
\DeclareUnicodeCharacter{8404}{\ensuremath{\minusfdots}}
\DeclareUnicodeCharacter{120001}{\ensuremath{\ell}}
\DeclareUnicodeCharacter{10788}{\ensuremath{\tilde +}}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{agda}
\usepackage{forest}
\usepackage{cite}
\begin{document}
\title{AVL Trees}
\author{D Ois√≠n Kidney}
\maketitle
\abstract{
  This is a verified implementation of AVL trees in Agda, taking ideas
  primarily from Conor McBride's paper ``How to Keep Your Neighbours in
  Order'' \cite{mcbride_how_2014} and the Agda standard library
  \cite{danielsson_agda_2018}.
}
\tableofcontents
\section{Introduction}
First, some imports.
\begin{code}
{-# OPTIONS --without-K #-}

open import Relation.Binary
open import Relation.Binary.PropositionalEquality
open import Level using (Lift; lift; _‚äî_; lower)
open import Data.Nat as ‚Ñï using (‚Ñï; suc; zero; pred)
open import Data.Product
open import Data.Unit
open import Data.Maybe
open import Function
open import Data.Bool
open import Data.Empty
\end{code}

Next, we declare a module: the entirety of the following code is
parameterized over the \emph{key} type, and a strict total order on
that key.
\begin{code}
module AVL
  {k r} (Key : Set k)
  {_<_ : Rel Key r}
  (isStrictTotalOrder : IsStrictTotalOrder _‚â°_ _<_)
  where

  open IsStrictTotalOrder isStrictTotalOrder
\end{code}
\section{Bounded}
The basic idea of the verified implementation is to store in each leaf
a proof that the upper and lower bounds of the trees to its left and
right are ordered appropriately.

Accordingly, the tree type itself will have to have the upper and
lower bounds in its indices. But what are the upper and lower bounds
of a tree with no neighbours? To describe this case, we add lower and
upper bounds to our key type.
\begin{code}
  module Bounded where

    infix 5 [_]

    data [‚àô] : Set k where
      ‚åä‚åã ‚åà‚åâ  : [‚àô]
      [_]    : (k : Key) ‚Üí [‚àô]
\end{code}

This type itself admits an ordering relation.
\begin{code}
    infix 4 _[<]_

    _[<]_ : [‚àô] ‚Üí [‚àô] ‚Üí Set r
    ‚åä‚åã     [<] ‚åä‚åã     = Lift r ‚ä•
    ‚åä‚åã     [<] ‚åà‚åâ     = Lift r ‚ä§
    ‚åä‚åã     [<] [ _ ]  = Lift r ‚ä§
    ‚åà‚åâ     [<] _      = Lift r ‚ä•
    [ _ ]  [<] ‚åä‚åã     = Lift r ‚ä•
    [ _ ]  [<] ‚åà‚åâ     = Lift r ‚ä§
    [ x ]  [<] [ y ]  = x < y
\end{code}

Finally, we can describe a value as being ``in bounds'' like so.
\begin{code}
    infix 4 _<_<_

    _<_<_ : [‚àô] ‚Üí Key ‚Üí [‚àô] ‚Üí Set r
    l < x < u = l [<] [ x ] √ó [ x ] [<] u
\end{code}
\section{Balance}
To describe the balance of the tree, we use the following type:
\begin{code}
    data ‚ü®_‚äî_‚ü©‚â°_ : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí Set where
      ‚óø   : ‚àÄ {n} ‚Üí ‚ü® suc  n ‚äî      n ‚ü©‚â° suc  n
      ‚ñΩ   : ‚àÄ {n} ‚Üí ‚ü®      n ‚äî      n ‚ü©‚â°      n
      ‚ó∫   : ‚àÄ {n} ‚Üí ‚ü®      n ‚äî suc  n ‚ü©‚â° suc  n
\end{code}
The tree can be either left- or right-heavy (by one), or even. The
indices of the type are phrased as a proof:
\begin{equation}
  max(x,y) = z
\end{equation}
The height of a tree is the maximum height of its two subtrees, plus
one. Storing a proof of the maximum in this way will prove useful
later.

We will also need some combinators for balance:
\begin{code}
    ‚Éï : ‚àÄ {x y z} ‚Üí ‚ü® x ‚äî y ‚ü©‚â° z ‚Üí ‚ü® z ‚äî x ‚ü©‚â° z
    ‚Éï  ‚óø   = ‚ñΩ
    ‚Éï  ‚ñΩ   = ‚ñΩ
    ‚Éï  ‚ó∫   = ‚óø

    ‚Éî : ‚àÄ {x y z} ‚Üí ‚ü® x ‚äî y ‚ü©‚â° z ‚Üí ‚ü® y ‚äî z ‚ü©‚â° z
    ‚Éî  ‚óø   = ‚ó∫
    ‚Éî  ‚ñΩ   = ‚ñΩ
    ‚Éî  ‚ó∫   = ‚ñΩ
\end{code}
\section{The Tree Type}
The type itself is indexed by the lower and upper bounds, some
value to store with the keys, and a height. In using the balance type
defined earlier, we ensure that the children of a node cannot differ
in height by more than 1. The bounds proofs also ensure that the tree
must be ordered correctly.
\begin{code}
    data Tree  {v}
               (V : Key ‚Üí Set v)
               (l u : [‚àô]) : ‚Ñï ‚Üí
               Set (k ‚äî v ‚äî r) where
      leaf  : (l<u : l [<] u) ‚Üí Tree V l u 0
      node  : ‚àÄ  {h lh rh}
                 (k : Key)
                 (v : V k)
                 (bl : ‚ü® lh ‚äî rh ‚ü©‚â° h)
                 (lk : Tree V l [ k ] lh)
                 (ku : Tree V [ k ] u rh) ‚Üí
                 Tree V l u (suc h)
\end{code}
\section{Rotations}
AVL trees are rebalanced by rotations: if, after an insert or deletion,
the balance invariant has been violated, one of these rotations is
performed as correction.

Before we implement the rotations, we need a way to describe a tree
which may have increased in height. We can do this with a
\emph{descriptive} type:
\begin{code}
    _1?+‚ü®_‚ü©    : ‚àÄ {ùìÅ} (T : ‚Ñï ‚Üí Set ùìÅ) ‚Üí ‚Ñï ‚Üí Set ùìÅ
    T 1?+‚ü® n ‚ü© = ‚àÉ[ inc? ] T (if inc? then suc n else n)

    pattern 0+_ tr = false , tr
    pattern 1+_ tr = true  , tr
\end{code}
Later, we will also need to describe a tree which may have decreased
in height. For this, we will use a \emph{prescriptive} type (in other
words, where the previous type was parameterized, this one will be
indexed).
\begin{code}
    data _‚ü®_‚ü©?‚àí1 {‚Ñì} (T : ‚Ñï ‚Üí Set ‚Ñì) : ‚Ñï ‚Üí Set ‚Ñì where
      _‚àí0 : ‚àÄ {n} ‚Üí T n ‚Üí T ‚ü® n ‚ü©?‚àí1
      _‚àí1 : ‚àÄ {n} ‚Üí T n ‚Üí T ‚ü® suc n ‚ü©?‚àí1
\end{code}

Whereas the previous construction would tell you the height of a tree
after pattern matching on it, this definition will \emph{refine} any
information you already have about the height of the tree.

In certain circumstances, you can convert between the two:
\begin{code}
    1?+‚ü®_‚ü©‚áí?‚àí1  : ‚àÄ {n ùìÅ} {T : ‚Ñï ‚Üí Set ùìÅ}
                ‚Üí T 1?+‚ü® n ‚ü©
                ‚Üí T ‚ü® suc n ‚ü©?‚àí1
    1?+‚ü® 0+ x ‚ü©‚áí?‚àí1 = x ‚àí1
    1?+‚ü® 1+ x ‚ü©‚áí?‚àí1 = x ‚àí0
\end{code}
\subsection{Right Rotation}
When the left subtree becomes too heavy, we rotate the tree to the
right.
\begin{code}
    rot ≥  : ‚àÄ {lb ub rh v} {V : Key ‚Üí Set v}
          ‚Üí (k : Key)
          ‚Üí V k
          ‚Üí Tree V lb [ k ] (suc (suc rh))
          ‚Üí Tree V [ k ] ub rh
          ‚Üí Tree V lb ub 1?+‚ü® suc (suc rh) ‚ü©
\end{code}
This rotation comes in two varieties: single and double. Single
rotation can be seen in figure~\ref{rightsingle}.
\begin{figure}[h]
  \centering
  \begin{forest}
      [ $x$, AgdaInductiveConstructor
            [ $y$, AgdaInductiveConstructor
                  [ $a$, AgdaField ]
                  [ $b$, AgdaField ]]
            [ $c$, AgdaField ]]
  \end{forest}
  \raisebox{1cm}{
    \begin{tikzpicture}
      \draw[->] (0,0) -- (1,0);
    \end{tikzpicture}
  }
  \begin{forest}
      [ $y$, AgdaInductiveConstructor
            [ $a$, AgdaField ]
            [ $x$, AgdaInductiveConstructor
                  [ $b$, AgdaField ]
                  [ $c$, AgdaField ]]]
  \end{forest}
  \caption{Single right-rotation}
  \label{rightsingle}
\end{figure}
\begin{code}
    rot ≥ x xv (node y yv ‚óø a b) c =
      0+ (node y yv ‚ñΩ a (node x xv ‚ñΩ  b c))
    rot ≥ x xv (node y yv ‚ñΩ a b) c =
      1+ (node y yv ‚ó∫ a (node x xv ‚óø  b c))
\end{code}
And double rotation in figure~\ref{rightdouble}.
\begin{figure}[h]
  \centering
  \begin{forest}
      [ $x$, AgdaInductiveConstructor
            [ $y$, AgdaInductiveConstructor
                  [ $a$, AgdaField ]
                  [ $z$, AgdaInductiveConstructor
                        [ $b$, AgdaField ]
                        [ $c$, AgdaField ]]]
            [ $d$, AgdaField ]]
  \end{forest}
  \raisebox{1cm}{
    \begin{tikzpicture}
      \draw[->] (0,0) -- (1,0);
    \end{tikzpicture}
  }
  \begin{forest}
      [ $z$, AgdaInductiveConstructor
            [ $y$, AgdaInductiveConstructor
                  [ $a$, AgdaField ]
                  [ $b$, AgdaField ]]
            [ $x$, AgdaInductiveConstructor
                  [ $c$, AgdaField ]
                  [ $d$, AgdaField ]]]
  \end{forest}
  \caption{Double right-rotation}
  \label{rightdouble}
\end{figure}
\begin{code}
    rot ≥ x xv (node y yv ‚ó∫  a (node z zv bl b c)) d =
      0+ (node z zv ‚ñΩ (node y yv (‚Éï bl) a b) (node x xv (‚Éî bl) c d))
\end{code}
\subsection{Left Rotation}
Left-rotation is essentially the inverse of right.
\begin{code}
    rotÀ°  : ‚àÄ {lb ub lh v} {V : Key ‚Üí Set v}
          ‚Üí (k : Key)
          ‚Üí V k
          ‚Üí Tree V lb [ k ] lh
          ‚Üí Tree V [ k ] ub (suc (suc lh))
          ‚Üí Tree V lb ub 1?+‚ü® suc (suc lh) ‚ü©
\end{code}
\begin{figure}[h!]
  \centering
  \begin{forest}
    [ $x$, AgdaInductiveConstructor
           [ $c$, AgdaField ]
           [ $y$, AgdaInductiveConstructor
                  [ $b$, AgdaField ]
                  [ $a$, AgdaField ]]]
  \end{forest}
  \raisebox{1cm}{
    \begin{tikzpicture}
      \draw[->] (0,0) -- (1,0);
    \end{tikzpicture}
  }
  \begin{forest}
    [ $y$, AgdaInductiveConstructor
           [ $x$, AgdaInductiveConstructor
                  [ $c$, AgdaField ]
                  [ $b$, AgdaField ]]
           [ $a$, AgdaField ]]
  \end{forest}
  \caption{Single left-rotation}
  \label{leftsingle}
\end{figure}
Single (seen in figure~\ref{leftsingle}).
\begin{code}
    rotÀ° x xv c (node y yv ‚ó∫ b a) =
      0+ (node y yv ‚ñΩ (node x xv ‚ñΩ c b) a)
    rotÀ° x xv c (node y yv ‚ñΩ b a) =
      1+ (node y yv ‚óø (node x xv ‚ó∫ c b) a)
\end{code}
\begin{figure}[h!]
  \centering
  \begin{forest}
    [ $x$, AgdaInductiveConstructor
          [ $d$, AgdaField ]
          [ $y$, AgdaInductiveConstructor
                [ $z$, AgdaInductiveConstructor
                      [ $c$, AgdaField ]
                      [ $b$, AgdaField ]]
                [ $a$, AgdaField ]]]
  \end{forest}
  \raisebox{1cm}{
    \begin{tikzpicture}
      \draw[->] (0,0) -- (1,0);
    \end{tikzpicture}
  }
  \begin{forest}
    [ $z$, AgdaInductiveConstructor
          [ $x$, AgdaInductiveConstructor
                [ $d$, AgdaField ]
                [ $c$, AgdaField ]]
          [ $y$, AgdaInductiveConstructor
                [ $b$, AgdaField ]
                [ $a$, AgdaField ]]
    ]
  \end{forest}
  \caption{Double left-rotation}
  \label{leftdouble}
\end{figure}
and double (figure~\ref{leftdouble}):
\begin{code}
    rotÀ° x xv d (node y yv  ‚óø  (node z zv bl c b) a) =
      0+ (node z zv ‚ñΩ (node x xv (‚Éï bl) d c) (node y yv (‚Éî bl) b a))
\end{code}
\section{Insertion}
After the rotations, insertion is relatively easy. We allow the caller
to supply a combining function.
\begin{code}
    insert   : ‚àÄ {l u h v} {V : Key ‚Üí Set v} (k : Key)
             ‚Üí V k
             ‚Üí (V k ‚Üí V k ‚Üí V k)
             ‚Üí Tree V l u h
             ‚Üí l < k < u
             ‚Üí Tree V l u 1?+‚ü® h ‚ü©
    insert v vc f (leaf l<u) (l , u) = 1+ (node v vc ‚ñΩ (leaf l) (leaf u))
    insert v vc f (node k kc bl tl tr) prf with compare v k
    insert v vc f (node k kc bl tl tr) (l , _)
         | tri< a _ _ with insert v vc f tl (l , a)
    ...  | 0+ tl‚Ä≤ = 0+ (node k kc bl tl‚Ä≤ tr)
    ...  | 1+ tl‚Ä≤ with bl
    ...  | ‚óø = rot ≥ k kc tl‚Ä≤ tr
    ...  | ‚ñΩ = 1+  (node k kc  ‚óø  tl‚Ä≤ tr)
    ...  | ‚ó∫ = 0+  (node k kc  ‚ñΩ  tl‚Ä≤ tr)
    insert v vc f (node k kc bl tl tr) _
         | tri‚âà _ refl _ = 0+ (node k (f vc kc) bl tl tr)
    insert v vc f (node k kc bl tl tr) (_ , u)
         | tri> _ _ c with insert v vc f tr (c , u)
    ...  | 0+ tr‚Ä≤ = 0+ (node k kc bl tl tr‚Ä≤)
    ...  | 1+ tr‚Ä≤ with bl
    ...  | ‚óø = 0+  (node k kc  ‚ñΩ  tl tr‚Ä≤)
    ...  | ‚ñΩ = 1+  (node k kc  ‚ó∫  tl tr‚Ä≤)
    ...  | ‚ó∫ = rotÀ° k kc tl tr‚Ä≤
\end{code}
\section{Lookup}
Lookup is also very simple. No invariants are needed here.
\begin{code}
    lookup  : (k : Key)
            ‚Üí ‚àÄ {l u s v} {V : Key ‚Üí Set v}
            ‚Üí Tree V l u s
            ‚Üí Maybe (V k)
    lookup k (leaf l<u) = nothing
    lookup k (node v vc _ tl tr) with compare k v
    ... | tri< _ _ _     = lookup k tl
    ... | tri‚âà _ refl _  = just vc
    ... | tri> _ _ _     = lookup k tr
\end{code}
\section{Deletion}
Deletion is by far the most complex operation out of the three
provided here. For deletion from a normal BST, you go to the node
where the desired value is, perform an ``uncons'' operation on the
right subtree, use that as your root node, and merge the two
remaining children.

\subsection{Uncons}
First then, we need to define ``uncons''. We'll use a custom type as
the return type from our uncons function, which stores the minimum
element from the tree, and the rest of the tree:
\begin{code}
    record Cons {v}
                (V : Key ‚Üí Set v)
                (lb ub : [‚àô])
                (h : ‚Ñï) : Set (k ‚äî v ‚äî r) where
      constructor cons
      field
        head  : Key
        val   : V head
        l<u   : lb [<] [ head ]
        tail  : Tree V [ head ] ub 1?+‚ü® h ‚ü©
\end{code}
You'll notice it also stores a proof that the extracted element
preserves the lower bound.
\begin{code}
    uncons   : ‚àÄ {lb ub h lh rh v} {V : Key ‚Üí Set v}
             ‚Üí (k : Key)
             ‚Üí V k
             ‚Üí ‚ü® lh ‚äî rh ‚ü©‚â° h
             ‚Üí Tree V lb [ k ] lh
             ‚Üí Tree V [ k ] ub rh
             ‚Üí Cons V lb ub h
    uncons k v b (leaf l<u) tr = cons k v l<u (case b of
      Œª  {  ‚ó∫  ‚Üí 0+ tr
         ;  ‚ñΩ  ‚Üí 0+ tr })
    uncons k v b (node k‚Çó v‚Çó b‚Çó tl‚Çó tr‚Çó) tr with uncons k‚Çó v‚Çó b‚Çó tl‚Çó tr‚Çó
    ... | cons k‚Ä≤ v‚Ä≤ l<u tail = cons k‚Ä≤ v‚Ä≤ l<u (case tail of
        Œª  {  (1+ tl‚Ä≤) ‚Üí 1+ (node k v b tl‚Ä≤ tr)
           ;  (0+ tl‚Ä≤) ‚Üí case b of
                 Œª {  ‚óø  ‚Üí 0+ node k v ‚ñΩ  tl‚Ä≤ tr
                   ;  ‚ñΩ  ‚Üí 1+ node k v ‚ó∫  tl‚Ä≤ tr
                   ;  ‚ó∫  ‚Üí rotÀ° k v tl‚Ä≤ tr }})
\end{code}
\subsection{Widening and Transitivity}
To join the two subtrees together after a deletion operation, we need
to weaken (or ext) the bounds of the left tree. This is an
$\mathcal{O}(\log n)$ operation.

For the exting, we'll need some properties on orderings:
\begin{code}
    x‚âÆ‚åä‚åã : ‚àÄ {x} ‚Üí x [<] ‚åä‚åã ‚Üí Lift r ‚ä•
    x‚âÆ‚åä‚åã {‚åä‚åã}     = lift ‚àò lower
    x‚âÆ‚åä‚åã {‚åà‚åâ}     = lift ‚àò lower
    x‚âÆ‚åä‚åã {[ _ ]}  = lift ‚àò lower

    [<]-trans : ‚àÄ x {y z} ‚Üí x [<] y ‚Üí y [<] z ‚Üí x [<] z
    [<]-trans ‚åä‚åã     {y}      {‚åä‚åã}     _    y<z  = x‚âÆ‚åä‚åã {x = y} y<z
    [<]-trans ‚åä‚åã     {_}      {‚åà‚åâ}     _    _    = _
    [<]-trans ‚åä‚åã     {_}      {[ _ ]}  _    _    = _
    [<]-trans ‚åà‚åâ     {_}      {_}      (lift ()) _
    [<]-trans [ _ ]  {y}      {‚åä‚åã}     _    y<z  = x‚âÆ‚åä‚åã {x = y} y<z
    [<]-trans [ _ ]  {_}      {‚åà‚åâ}     _    _    = _
    [<]-trans [ _ ]  {‚åä‚åã}     {[ _ ]}  (lift ()) _
    [<]-trans [ _ ]  {‚åà‚åâ}     {[ _ ]}  _ (lift ())
    [<]-trans [ x ]  {[ y ]}  {[ z ]}  x<y  y<z  =
      IsStrictTotalOrder.trans isStrictTotalOrder x<y y<z
\end{code}
Finally, the ext function itself simply walks down the right branch
of the tree until it hits a leaf.
\begin{code}
    ext : ‚àÄ {lb ub ub‚Ä≤ h v} {V : Key ‚Üí Set v}
         ‚Üí ub [<] ub‚Ä≤
         ‚Üí Tree V lb ub h
         ‚Üí Tree V lb ub‚Ä≤ h
    ext {lb} ub<ub‚Ä≤ (leaf l<u) = leaf ([<]-trans lb l<u ub<ub‚Ä≤)
    ext ub<ub‚Ä≤ (node k v bl tl tr) = node k v bl tl (ext ub<ub‚Ä≤ tr)
\end{code}
\subsection{Joining}
Once we have the two subtrees that will form the children of our
replaced node, we need to join them together, adjusting the types
accordingly.
\begin{code}
    join : ‚àÄ {lb ub lh rh h v k} {V : Key ‚Üí Set v}
         ‚Üí Tree V [ k ] ub rh
         ‚Üí ‚ü® lh ‚äî rh ‚ü©‚â° h
         ‚Üí Tree V lb [ k ] lh
         ‚Üí Tree V lb ub 1?+‚ü® h ‚ü©
    join (leaf k<ub) ‚óø tl = 0+ ext k<ub tl
    join {lb} (leaf k<ub) ‚ñΩ (leaf lb<k) =
      0+ leaf ([<]-trans lb lb<k k<ub)
    join (node k·µ£ v·µ£ b·µ£ tl·µ£ tr·µ£) b  tl with uncons k·µ£ v·µ£ b·µ£ tl·µ£ tr·µ£
    ... | cons k‚Ä≤ v‚Ä≤ l<u (1+ tr‚Ä≤) = 1+ node k‚Ä≤ v‚Ä≤ b  (ext l<u tl) tr‚Ä≤
    ... | cons k‚Ä≤ v‚Ä≤ l<u (0+ tr‚Ä≤) with b
    ... | ‚óø = rot ≥ k‚Ä≤ v‚Ä≤ (ext l<u tl) tr‚Ä≤
    ... | ‚ñΩ = 1+ node k‚Ä≤ v‚Ä≤ ‚óø  (ext l<u tl) tr‚Ä≤
    ... | ‚ó∫ = 0+ node k‚Ä≤ v‚Ä≤ ‚ñΩ  (ext l<u tl) tr‚Ä≤
\end{code}
\subsection{Full Deletion}
The deletion function is by no means simple, but it does maintain the
correct complexity bounds.
\begin{code}
    delete : ‚àÄ {lb ub h v} {V : Key ‚Üí Set v}
           ‚Üí (k : Key)
           ‚Üí Tree V lb ub h
           ‚Üí Tree V lb ub ‚ü® h ‚ü©?‚àí1
    delete x (leaf l<u) = leaf l<u ‚àí0
    delete x (node y yv b l r) with compare x y
    delete x (node .x yv b l r) | tri‚âà _ refl _ = 1?+‚ü® join r b l ‚ü©‚áí?‚àí1
    delete x (node y yv b l r) | tri< a _ _ with delete x l
    ... | l‚Ä≤ ‚àí0 = node y yv b l‚Ä≤ r ‚àí0
    ... | l‚Ä≤ ‚àí1 with b
    ... | ‚óø  = node y yv ‚ñΩ  l‚Ä≤ r ‚àí1
    ... | ‚ñΩ  = node y yv ‚ó∫  l‚Ä≤ r ‚àí0
    ... | ‚ó∫  = 1?+‚ü® rotÀ° y yv l‚Ä≤ r ‚ü©‚áí?‚àí1
    delete x (node y yv b l r) | tri> _ _ c with delete x r
    ... | r‚Ä≤ ‚àí0 = node y yv b l r‚Ä≤ ‚àí0
    ... | r‚Ä≤ ‚àí1 with b
    ... | ‚óø  = 1?+‚ü® rot ≥ y yv l r‚Ä≤ ‚ü©‚áí?‚àí1
    ... | ‚ñΩ  = node y yv ‚óø  l r‚Ä≤ ‚àí0
    ... | ‚ó∫  = node y yv ‚ñΩ  l r‚Ä≤ ‚àí1
\end{code}
\section{Alteration}
This is a combination of insertion and deletion: it lets the user
supply a function to modify, insert, or remove an element, depending
on the element already in the tree.

As it can both increase and decrease the size of the tree, we need a
wrapper to represent that:
\begin{code}
    data _‚ü®_‚ü©¬±1 {‚Ñì} (T : ‚Ñï ‚Üí Set ‚Ñì) : ‚Ñï ‚Üí Set ‚Ñì where
      1+‚ü®_‚ü©  : ‚àÄ {n} ‚Üí T (suc n)  ‚Üí T ‚ü® n ‚ü©¬±1
      ‚ü®_‚ü©    : ‚àÄ {n} ‚Üí T n        ‚Üí T ‚ü® n ‚ü©¬±1
      ‚ü®_‚ü©‚àí1  : ‚àÄ {n} ‚Üí T n        ‚Üí T ‚ü® suc n ‚ü©¬±1

    1?+‚ü®_‚ü©‚áí‚àí1  : ‚àÄ {n ‚Ñì} {T : ‚Ñï ‚Üí Set ‚Ñì}
              ‚Üí T 1?+‚ü® n ‚ü©
              ‚Üí T ‚ü® suc n ‚ü©¬±1
    1?+‚ü® 0+ x ‚ü©‚áí‚àí1 = ‚ü® x ‚ü©‚àí1
    1?+‚ü® 1+ x ‚ü©‚áí‚àí1 = ‚ü® x ‚ü©

    1?+‚ü®_‚ü©‚áí+1  : ‚àÄ {n ‚Ñì} {T : ‚Ñï ‚Üí Set ‚Ñì}
              ‚Üí T 1?+‚ü® n ‚ü©
              ‚Üí T ‚ü® n ‚ü©¬±1
    1?+‚ü® 0+ x ‚ü©‚áí+1 = ‚ü® x ‚ü©
    1?+‚ü® 1+ x ‚ü©‚áí+1 = 1+‚ü® x ‚ü©
\end{code}
And then the function itself. It's long, but you should be able to see
the deletion and insertion components.
\begin{code}
    alter : ‚àÄ {lb ub h v} {V : Key ‚Üí Set v}
          ‚Üí (k : Key)
          ‚Üí (Maybe (V k) ‚Üí Maybe (V k))
          ‚Üí Tree V lb ub h
          ‚Üí lb < k < ub
          ‚Üí Tree V lb ub ‚ü® h ‚ü©¬±1
    alter x f (leaf l<u) (l , u) with f nothing
    ...  | just xv  = 1+‚ü® node x xv ‚ñΩ (leaf l) (leaf u) ‚ü©
    ...  | nothing  = ‚ü® leaf l<u ‚ü©
    alter x f (node y yv b tl tr) (l , u)
      with compare x y
    alter x f (node .x yv b tl tr) (l , u)
         | tri‚âà _ refl _ with f (just yv)
    ...  | just xv  = ‚ü® node x xv b tl tr ‚ü©
    ...  | nothing  = 1?+‚ü® join tr b tl ‚ü©‚áí‚àí1
    alter x f (node y yv b tl tr) (l , u)
         | tri< a _ _ with alter x f tl (l , a) | b
    ...  | ‚ü® tl‚Ä≤ ‚ü©    | _  = ‚ü® node y yv b  tl‚Ä≤ tr ‚ü©
    ...  | 1+‚ü® tl‚Ä≤ ‚ü©  | ‚óø  = 1?+‚ü® rot ≥ y yv tl‚Ä≤ tr ‚ü©‚áí+1
    ...  | 1+‚ü® tl‚Ä≤ ‚ü©  | ‚ñΩ  = 1+‚ü® node y yv ‚óø  tl‚Ä≤ tr ‚ü©
    ...  | 1+‚ü® tl‚Ä≤ ‚ü©  | ‚ó∫  = ‚ü® node y yv ‚ñΩ  tl‚Ä≤ tr ‚ü©
    ...  | ‚ü® tl‚Ä≤ ‚ü©‚àí1  | ‚óø  = ‚ü® node y yv ‚ñΩ  tl‚Ä≤ tr ‚ü©‚àí1
    ...  | ‚ü® tl‚Ä≤ ‚ü©‚àí1  | ‚ñΩ  = ‚ü® node y yv ‚ó∫  tl‚Ä≤ tr ‚ü©
    ...  | ‚ü® tl‚Ä≤ ‚ü©‚àí1  | ‚ó∫  = 1?+‚ü® rotÀ° y yv tl‚Ä≤ tr ‚ü©‚áí‚àí1
    alter x f (node y yv b tl tr) (l , u)
         | tri> _ _ c with alter x f tr (c , u) | b
    ...  | ‚ü® tr‚Ä≤ ‚ü©    | _  = ‚ü® node y yv b  tl tr‚Ä≤ ‚ü©
    ...  | 1+‚ü® tr‚Ä≤ ‚ü©  | ‚óø  = ‚ü® node y yv ‚ñΩ  tl tr‚Ä≤ ‚ü©
    ...  | 1+‚ü® tr‚Ä≤ ‚ü©  | ‚ñΩ  = 1+‚ü® node y yv ‚ó∫  tl tr‚Ä≤ ‚ü©
    ...  | 1+‚ü® tr‚Ä≤ ‚ü©  | ‚ó∫  = 1?+‚ü® rotÀ° y yv tl tr‚Ä≤ ‚ü©‚áí+1
    ...  | ‚ü® tr‚Ä≤ ‚ü©‚àí1  | ‚óø  = 1?+‚ü® rot ≥ y yv tl tr‚Ä≤ ‚ü©‚áí‚àí1
    ...  | ‚ü® tr‚Ä≤ ‚ü©‚àí1  | ‚ñΩ  = ‚ü® node y yv ‚óø  tl tr‚Ä≤ ‚ü©
    ...  | ‚ü® tr‚Ä≤ ‚ü©‚àí1  | ‚ó∫  = ‚ü® node y yv ‚ñΩ  tl tr‚Ä≤ ‚ü©‚àí1
\end{code}
We can also write alterF, in the lens style.
\begin{code}
    open import Category.Functor using (RawFunctor)

    MaybeVal : ‚àÄ {v} (V : Set v) ‚Üí Set (k ‚äî r ‚äî v)
    MaybeVal V = Lift (k ‚äî r) (Maybe V)

    alterF : ‚àÄ {lb ub h v} {V : Key ‚Üí Set v}
          ‚Üí (x : Key)
          ‚Üí ‚àÄ  {F : Set (k ‚äî r ‚äî v) ‚Üí Set (k ‚äî r ‚äî v)}
               {{functor : RawFunctor F}}
          ‚Üí (Maybe (V x) ‚Üí F (MaybeVal (V x)))
          ‚Üí Tree V lb ub h
          ‚Üí lb < x < ub
          ‚Üí F (Tree V lb ub ‚ü® h ‚ü©¬±1)
    alterF {lb} {ub} {h} {_} {V} x {F} {{functor}} f root bnds
      = go root bnds id
      where
      _<&>_ : ‚àÄ {A B} ‚Üí F A ‚Üí (A ‚Üí B) ‚Üí F B
      xs <&> f = RawFunctor._<$>_ functor f xs
      go  : ‚àÄ {lb‚Ä≤ ub‚Ä≤ h‚Ä≤}
          ‚Üí Tree V lb‚Ä≤ ub‚Ä≤ h‚Ä≤
          ‚Üí lb‚Ä≤ < x < ub‚Ä≤
          ‚Üí (Tree V lb‚Ä≤ ub‚Ä≤ ‚ü® h‚Ä≤ ‚ü©¬±1 ‚Üí Tree V lb ub ‚ü® h ‚ü©¬±1)
          ‚Üí F (Tree V lb ub ‚ü® h ‚ü©¬±1)
      go (leaf l<u) (l , u) k = f nothing <&>
       Œª  {  (lift nothing)    ‚Üí ‚ü® root ‚ü©
          ;  (lift (just xv))  ‚Üí  k 1+‚ü® node x xv ‚ñΩ (leaf l) (leaf u) ‚ü© }
      go (node y yv b tl tr) (l , u) k with compare x y
      go (node .x yv b tl tr) (l , u) k | tri‚âà _ refl _ = f (just yv) <&>
       Œª  {  (lift nothing)    ‚Üí k 1?+‚ü® join tr b tl ‚ü©‚áí‚àí1
          ;  (lift (just xv))  ‚Üí k ‚ü® node x xv b tl tr ‚ü©}
      go (node y yv b tl tr) (l , u) k | tri< a _ _ = go tl (l , a) (k ‚àò
       Œª  {  ‚ü® tl‚Ä≤ ‚ü© ‚Üí ‚ü® node y yv b tl‚Ä≤ tr ‚ü©
          ;  1+‚ü® tl‚Ä≤ ‚ü© ‚Üí case b of
             Œª {  ‚óø  ‚Üí 1?+‚ü® rot ≥ y yv tl‚Ä≤ tr ‚ü©‚áí+1
               ;  ‚ñΩ  ‚Üí 1+‚ü® node y yv ‚óø  tl‚Ä≤ tr ‚ü©
               ;  ‚ó∫  ‚Üí ‚ü® node y yv ‚ñΩ  tl‚Ä≤ tr ‚ü© }
          ;  ‚ü® tl‚Ä≤ ‚ü©‚àí1 ‚Üí case b of
             Œª {  ‚óø  ‚Üí ‚ü® node y yv ‚ñΩ  tl‚Ä≤ tr ‚ü©‚àí1
               ;  ‚ñΩ  ‚Üí ‚ü® node y yv ‚ó∫  tl‚Ä≤ tr ‚ü©
               ;  ‚ó∫  ‚Üí 1?+‚ü® rotÀ° y yv tl‚Ä≤ tr ‚ü©‚áí‚àí1 }})
      go (node y yv b tl tr) (l , u) k | tri> _ _ c = go tr (c , u) (k ‚àò
       Œª  {  ‚ü® tr‚Ä≤ ‚ü© ‚Üí ‚ü® node y yv b tl tr‚Ä≤ ‚ü©
          ;  1+‚ü® tr‚Ä≤ ‚ü© ‚Üí case b of
             Œª {  ‚óø  ‚Üí ‚ü® node y yv ‚ñΩ  tl tr‚Ä≤ ‚ü©
               ;  ‚ñΩ  ‚Üí 1+‚ü® node y yv ‚ó∫  tl tr‚Ä≤ ‚ü©
               ;  ‚ó∫  ‚Üí 1?+‚ü® rotÀ° y yv tl tr‚Ä≤ ‚ü©‚áí+1 }
          ;  ‚ü® tr‚Ä≤ ‚ü©‚àí1 ‚Üí case b of
             Œª {  ‚óø  ‚Üí 1?+‚ü® rot ≥ y yv tl tr‚Ä≤ ‚ü©‚áí‚àí1
               ;  ‚ñΩ  ‚Üí ‚ü® node y yv ‚óø  tl tr‚Ä≤ ‚ü©
               ;  ‚ó∫  ‚Üí ‚ü® node y yv ‚ñΩ  tl tr‚Ä≤ ‚ü©‚àí1 }})
\end{code}
\section{Packaging}
Users don't need to be exposed to the indices on the full tree type:
here, we package it in thee forms.
\subsection{Dependent Map}
\begin{code}
  module DependantMap where
    data Map {v} (V : Key ‚Üí Set v) : Set (k ‚äî v ‚äî r) where
      tree  : ‚àÄ {h}
            ‚Üí Bounded.Tree V Bounded.‚åä‚åã Bounded.‚åà‚åâ h
            ‚Üí Map V

    insertWith  : ‚àÄ {v} {V : Key ‚Üí Set v} (k : Key)
                ‚Üí V k
                ‚Üí (V k ‚Üí V k ‚Üí V k)
                ‚Üí Map V
                ‚Üí Map V
    insertWith k v f (tree tr) =
      tree (proj‚ÇÇ (Bounded.insert k v f tr (lift tt , lift tt)))

    insert : ‚àÄ  {v}
                {V : Key ‚Üí Set v}
                (k : Key) ‚Üí
                V k ‚Üí
                Map V ‚Üí
                Map V
    insert k v = insertWith k v const

    lookup  : (k : Key)
            ‚Üí ‚àÄ {v} {V : Key ‚Üí Set v}
            ‚Üí Map V
            ‚Üí Maybe (V k)
    lookup k (tree tr) = Bounded.lookup k tr

    delete  : (k : Key)
            ‚Üí ‚àÄ {v} {V : Key ‚Üí Set v}
            ‚Üí Map V
            ‚Üí Map V
    delete k (tree tr) with Bounded.delete k tr
    ... | tr‚Ä≤ Bounded.‚àí0 = tree tr‚Ä≤
    ... | tr‚Ä≤ Bounded.‚àí1 = tree tr‚Ä≤

    alter  : (k : Key)
           ‚Üí ‚àÄ {v} {V : Key ‚Üí Set v}
           ‚Üí (Maybe (V k) ‚Üí Maybe (V k))
           ‚Üí Map V
           ‚Üí Map V
    alter k f (tree tr) with Bounded.alter k f tr (lift tt , lift tt)
    ... | Bounded.1+‚ü® tr‚Ä≤ ‚ü©  = tree tr‚Ä≤
    ... | Bounded.‚ü® tr‚Ä≤ ‚ü©    = tree tr‚Ä≤
    ... | Bounded.‚ü® tr‚Ä≤ ‚ü©‚àí1  = tree tr‚Ä≤
\end{code}
\subsection{Non-Dependent (Simple) Map}
\begin{code}
  module Map where
    data Map {v} (V : Set v) : Set (k ‚äî v ‚äî r) where
      tree  : ‚àÄ {h}
            ‚Üí Bounded.Tree (const V) Bounded.‚åä‚åã Bounded.‚åà‚åâ h
            ‚Üí Map V

    insertWith  : ‚àÄ {v} {V : Set v} (k : Key)
                ‚Üí V
                ‚Üí (V ‚Üí V ‚Üí V)
                ‚Üí Map V
                ‚Üí Map V
    insertWith k v f (tree tr) =
      tree (proj‚ÇÇ (Bounded.insert k v f tr (lift tt , lift tt)))

    empty : ‚àÄ {v} {V : Set v} ‚Üí Map V
    empty = tree (Bounded.leaf (lift tt))

    insert : ‚àÄ {v} {V : Set v} (k : Key) ‚Üí V ‚Üí Map V ‚Üí Map V
    insert k v = insertWith k v const

    lookup : (k : Key) ‚Üí ‚àÄ {v} {V : Set v} ‚Üí Map V ‚Üí Maybe V
    lookup k (tree tr) = Bounded.lookup k tr

    delete : (k : Key) ‚Üí ‚àÄ {v} {V : Set v} ‚Üí Map V ‚Üí Map V
    delete k (tree tr) with Bounded.delete k tr
    ... | tr‚Ä≤ Bounded.‚àí0 = tree tr‚Ä≤
    ... | tr‚Ä≤ Bounded.‚àí1 = tree tr‚Ä≤

    alter  : (k : Key)
           ‚Üí ‚àÄ {v} {V : Set v}
           ‚Üí (Maybe V ‚Üí Maybe V)
           ‚Üí Map V
           ‚Üí Map V
    alter k f (tree tr) with Bounded.alter k f tr (lift tt , lift tt)
    ... | Bounded.1+‚ü® tr‚Ä≤ ‚ü©  = tree tr‚Ä≤
    ... | Bounded.‚ü® tr‚Ä≤ ‚ü©    = tree tr‚Ä≤
    ... | Bounded.‚ü® tr‚Ä≤ ‚ü©‚àí1  = tree tr‚Ä≤
\end{code}
\subsection{Set}
Note that we can't call the type itself ``Set'', as that's a reserved
word in Agda.
\begin{code}
  module Sets where
    data ‚ü®Set‚ü© : Set (k ‚äî r) where
      tree  : ‚àÄ {h}
            ‚Üí Bounded.Tree (const ‚ä§) Bounded.‚åä‚åã Bounded.‚åà‚åâ h
            ‚Üí ‚ü®Set‚ü©

    insert : Key ‚Üí ‚ü®Set‚ü© ‚Üí ‚ü®Set‚ü©
    insert k (tree tr) =
      tree (proj‚ÇÇ (Bounded.insert k tt const tr (lift tt , lift tt)))

    member : Key ‚Üí ‚ü®Set‚ü© ‚Üí Bool
    member k (tree tr) = is-just (Bounded.lookup k tr)

    delete : (k : Key) ‚Üí ‚ü®Set‚ü© ‚Üí ‚ü®Set‚ü©
    delete k (tree tr) with Bounded.delete k tr
    ... | tr‚Ä≤ Bounded.‚àí0 = tree tr‚Ä≤
    ... | tr‚Ä≤ Bounded.‚àí1 = tree tr‚Ä≤
\end{code}
\bibliographystyle{IEEEtranS}
\bibliography{../AVL.bib}
\end{document}
